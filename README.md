# Hotwire: Server-render alerts for client-side actions

[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)][heroku-deploy-app]

[heroku-deploy-app]: https://heroku.com/deploy?template=https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-button-alert-template

[It all starts with HTML][].

[Stimulus][] controllers [synchronize their state with the document's
HTML][stimulus-state] through [attribute][]-backed [Values][] and
[element][]-backed [Targets][].

We'll explore its potential by re-creating a portion of the [_Building Something
Real_][] section of the [Stimulus Handbook][].

Since this interaction is _only_ client-side in the browser, there's an
opportunity to do as much work as possible on the server, to the point where the
client's responsibilities are constrained, only include appending to and
removing from document

* co-locates decisions about structure, content, styles, and element references
  in the same server-generated template
* declarative, pre-populated state

The advent of the [`<template>`][template] element poses an opportunity to
server-render HTML content.

[It All Starts With HTML]: https://stimulus.hotwired.dev/handbook/hello-stimulus#it-all-starts-with-html
[Stimulus]: https://stimulus.hotwired.dev/
[stimulus-state]: https://stimulus.hotwired.dev/handbook/managing-state
[attribute]: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
[element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element
[Values]: https://stimulus.hotwired.dev/handbook/managing-state#using-values
[Targets]: https://stimulus.hotwired.dev/reference/targets
[template]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template
[_Building Something Real_]: https://stimulus.hotwired.dev/handbook/building-something-real
[Stimulus Handbook]: https://stimulus.hotwired.dev/handbook/introduction

The code samples shared in this article omit the majority of the application's
setup. The initial code was generated by executing `rails new`. The rest of the
[source code][] from this article (including a [suite of tests][]) can be found
on GitHub, and is best read either [commit-by-commit][], or as a [unified
diff][].

[source code]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-button-alert-template
[suite of tests]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-button-alert-template
[commit-by-commit]: https://github.com/thoughtbot/hotwire-example-template/commits/hotwire-example-button-alert-template
[unified diff]: https://github.com/thoughtbot/hotwire-example-template/compare/hotwire-example-button-alert-template

## Our starting point

The `InvitationCodesController#show` action is our sole route. In our case, the
action serves as a simplified version of one that might generate an invitation
code on-the-fly, or read on from the database. Instead,
`InvitationCodesController#show` assigns the value of `params[:id]` into the
`@invitation_code` instance variable:

```ruby
# app/controllers/invitation_codes_controller.rb

class InvitationCodesController < ApplicationController
  def show
    @invitation_code = params[:id]
  end
end
```

For example, in response to a `GET` request for
<http://localhost:3000/invitation_codes/abc123>, would result in a response with
`abc123` as the invitation code.

The `app/views/invitation_codes/show.html.erb` template renders two `<fieldset>`
elements: one to copy the invitation code out of, and one to paste the
invitation code into:

```erb
<%# app/views/invitation_codes/show.html.erb %>

<fieldset>
  <legend>Copy</legend>

  <label>
    Invitation code

    <input value="<%= @invitation_code %>" readonly>
  </label>

  <button type="button" value="<%= @invitation_code %>"
          data-controller="clipboard"
          data-action="click->clipboard#copy">
    Copy to clipboard
  </button>
</fieldset>

<fieldset>
  <legend>Paste</legend>

  <label>
    Invitation code
    <input>
  </label>
</fieldset>
```

The first `<fieldset>` pairs an `<input>` element with a `<button>` element. The
`<input>` element is pre-populated with the invitation code and marked as
[readonly][]. The `<button>` is declares its [type="button"][], and [routes
`click` events][stimulus-actions] to the `clipboard` controller:

[type="button"]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-type
[readonly]: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly
[Clipboard's]: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard
[stimulus-actions]: https://stimulus.hotwired.dev/reference/actions

```javascript
// app/javascript/controllers/clipboard_controller.js

import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  copy({ target: { value } }) {
    navigator.clipboard.writeText(value)
  }
}
```

https://user-images.githubusercontent.com/2575027/154692773-cc91ff39-63e3-4e4e-857d-0657ea39d56e.mov

## Pushing alerts

First, we'll introduce the `app/views/application/_alert.html.erb` view partial:

```erb
<%# app/views/application/_alert.html.erb %>

<div role="alert" class="border border-solid rounded-md m-4 p-4">
  <%= yield %>
</div>
```

Next, we'll nest a `<template>` element within the `<button type="button">`.
Within the `<template>` element, we'll nest a [`<turbo-stream>`][turbo-stream]
element that's configured to [append][] its contents to an element marked with
[`[id="alerts"]`][id-attr]. Within the `<turbo-stream>` element's nested
`<template>`, we'll render the `app/views/application/_alert.html.erb` partial
with `Copied to clipboard` as its contents:

[turbo-stream]: https://turbo.hotwired.dev/reference/streams
[append]: https://developer.mozilla.org/en-US/docs/Web/API/Element/append
[id-attr]: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id

```diff
--- a/app/views/invitation_codes/show.html.erb
+++ b/app/views/invitation_codes/show.html.erb
   <button type="button" value="<%= @invitation_code %>"
           data-controller="clipboard"
           data-action="click->clipboard#copy">
     Copy to clipboard
+
+    <template>
+      <turbo-stream action="append" target="alerts">
+        <template>
+          <%= render "alert" do %>
+            Copied to clipboard
+          <% end %>
+        </template>
+      </turbo-stream>
+    </template>
   </button>
```

The `clone` controller retains access to an array of `<template>` elements
through its [`template` targets][stimulus-target]. The `append` action iterates
through the list, [clones][cloneNode] their [content][template-content], then
appends it to the document:

[template-content]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
[cloneNode]: https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
[stimulus-target]: https://stimulus.hotwired.dev/reference/targets

```javascript
// app/javascript/controllers/clone_controller.js

import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [ "template" ]

  append() {
    for (const { content } of this.templateTargets) {
      this.element.append(content.cloneNode(true))
    }
  }
}
```

We'll treat the outer `<template>` element as a `clone` target by marking it
with the `[data-clone-target="template"]` attribute, and we'll route `click`
events to a `clone` controller to [append][] the `<template>` element's contents
to the document whenever the `<button>` element is clicked:

```diff
--- a/app/views/invitation_codes/show.html.erb
+++ b/app/views/invitation_codes/show.html.erb
   <button type="button" value="<%= @invitation_code %>"
-          data-controller="clipboard"
+          data-controller="clipboard clone"
-          data-action="click->clipboard#copy">
+          data-action="click->clipboard#copy click->clone#append">
     Copy to clipboard

-    <template>
+    <template data-clone-target="template">
       <turbo-stream action="append" target="alerts">
         <template>
           <%= render "alert" do %>
             Copied to clipboard
           <% end %>
         </template>
       </turbo-stream>
     </template>
   </button>
```

Finally, we'll render an element with `[id="alerts"]` so that the
`<turbo-stream>` operation can append its contents:

```diff
--- a/app/views/invitation_codes/show.html.erb
+++ b/app/views/invitation_codes/show.html.erb
+<div id="alerts" class="absolute bottom-0 right-0 w-96"></div>
+
 <fieldset>
```

https://user-images.githubusercontent.com/2575027/154692364-0e5783e6-6197-4cff-95b4-256d80482896.mov

## Popping alerts

```diff
--- a/app/views/application/_alert.html.erb
+++ b/app/views/application/_alert.html.erb
-<div role="alert" class="border border-solid rounded-md m-4 p-4">
+<div role="alert" class="border border-solid rounded-md m-4 p-4"
+     data-controller="auto-remove" data-auto-remove-delay-value="10000">
   <%= yield %>
 </div>
```

```javascript
// app/javascript/controller/auto_remove_controller.js

import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static values = { delay: Number }

  connect() {
    this.timeoutID = setTimeout(() => this.element.remove(), this.delayValue)
  }

  disconnect() {
    clearTimeout(this.timeoutID)
  }
}
```

We're demonstrating a simplified version of this interaction. Production-ready
versions might animate the alert into and out of frame, delay removal if the
contents of the alert have focus, or prompt the user with a button to dismiss
the alert.

https://user-images.githubusercontent.com/2575027/154692670-9d718b67-7f1e-453e-8be8-c7617c86a915.mov

## Wrapping up

Included:

* an entirely client-side interaction augmented by server-generated HTML
* declaratively encoded DOM operations through `<template>` and `<turbo-stream>`
  elements
* three general purpose controllers with potential for re-use across the
  codebase

Excluded:

* parallel alert implementations split across the client-server boundary
* transforming JSON into HTML
* `XMLHttpRequest`, `fetch`
